近几年来，前端领域发展迅速，前端的工作早已不再是切几张图那么简单，项目比较大时，可能会多人协同开发。模块化，组件化，CSS预编译等概念也成了经常讨论的话题。

JavaScript，CSS代码的合并和压缩
CSS与预理器，Less，Sass，Stylus的编译
生成雪碧图（CSS Sprite）
ES6 转 ES5
模块化

如果使用过Gulp，并且了解RequireJS，上面几个问题应该难不倒你。只需配置几行代码，就可以实现对JS代码的合并与压缩。不过，经过Gulp合并压缩后的代码仍然是你写的代码，只是局部变量名被替换，一些语法做了转换而已，整体内容并没有发生变化。而本章要介绍的前端工程化工具webpack，打包后的代码已经不只是你写的代码，其中夹杂了很多webpack自身的模块处理代码。因此，学习webpack最难理解“编译”的这个概念，否则会一直存在一个疑问：为什么要这样做？
左边是在业务中写的各种格式的文件，比如typescript，less，jpg，还有本章后面要介绍的.vue格式的文件。这些格式的文件通过特定的加载器（Loader）编译后，最终统一生成为.js,.css,.png等静态资源文件。在webpack的世界里，一张图片，一个css甚至一个字体，都称为Module，彼此存在依赖关系，webpack就是来处理某块间的依赖关系的，并把他们进行打包。
举一个简单的例子，平时加载CSS大多通过<link>标签引入CSS文件，而webpack里，直接在一个.js文件中倒入，
import 'src/styles/index.css';
import 是ES 2015 的语法，这里也可以写成require('src/styles/index.css').在打包时，index.css会被打包进一个js文件里，通过动态创建`<style>`的形式来加载css样式，当然也可以进一步配置，在打包编译时把所有的css都提取出来，生成一个css的文件，后面会详细介绍。

webpack的主要适用场景是单页面富应用（SPA）。SPA通常是由一个html文件和一堆按需加载的js组成，它的html结构可能会非常简单
