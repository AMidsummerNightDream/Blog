在Vue的生态圈内提供了一个叫Vuex的库，专门用于状态共享与状态管理，，类似Flux。

Vue是一种完全基于组件化的可视化开发框架， 它的美在于我们会很自然地用设计原则来规划组件粒度与关系，用面向对象的思维来思考编程。然而当我们将视角拉近一点，关注那些流动在组件与组件之间的变量，尤其是哪些较为复杂的复合型组件，会发觉父组件与子组件之间，子代组件与其子组件之间的变量维护变得越来越不容易，由于Vue取消了属性的变量同步功能，父子组件之间的变量传递实际上是单项的：当子组件需要对传入的变量进行修改，同时又希望通知父组件传入的变量发生了变化时，则不得不使用事件冒泡来进行这种传递，最后在父组件中使用一个方法来进行重绘或者执行其它相应的行为，此类同性质操作又不能被封装为可重用代码，这样会不断地加大父组件与子组件之间的耦合度，让它们之间的关系变得错综复杂。
其次，cue-router可能是绝大多数的Vue项目都必不可少的工具库，有了vue-router，我们可以将一个组件视为一个页面来使用。由于组件只维护自身的状态（data），组件创建时或者说进入路由时它们被初始化，切换至其它的组件页自然要被销毁，从而导致data也随之销毁。页面与页面之间总会产生各种需要的共享变量，如果通过$router.param或者$router.meta来传递是远远不够的，很多情况下不得不采用window来保存一些全局的共享变量（很多的JavaScript框架或者库都是这样做的）。一旦这样就会陷入了新的困局，Vue是不会维护window的这些共享变量的。对于组件来讲，这些变量都存在于组件作用域以外，组件并不会“多管闲事”替我们托管。那我们就不得不手工来接管这些变量的赋值与读取。然而，只要我们知道一些基本的JS编程规范或者风格规范都会明白这么一条准则：全局变量是毒瘤，是具有极高副作用的。
Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储来管理应用所有组件的状态，并以相应的规则来保证状态以一种可预测的方式发生变化。Vuex也集成到Vue的官方调试工具devtools extension中，提供了诸如零配置的time-travel调试，状态快照导入等高级调试功能。
这个状态管理应用包含以下几个部分：
state--驱动应用的数据源，也就是各种共享变量；
view--以声明方式讲state映射到视图，也就是tempalte模版上引用这些state，让Vuex自动处理重绘；
actions--响应在view上用户输入导致的状态变化。

但是，当应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：
1.多个视图依赖于同一状态。
2.来自不同视图的行为需要变更为同一状态

对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们进常会采用父子组件直接引用，或者通过事件来变更和同步状态的多分副本的方式。以上的这些模式非常脆弱，通常会产生无法维护的代码。

因此，为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为

另外，通过定义和隔离状态管理中的各个概念并强制遵守一定的规则，代码将会变得更结构化且易维护

state---Vuex store实例的根状态对象，用于定义共享的状态变量，就像Vue实例中的data
getters--读取器，外部程序通过它获取变量的具体值，或者在取值前做一些计算（可以认为store的计算属性）。
actions--动作，向store发出调用通知，执行本地或者远端的某一个操作（可以理解为store的methods）
mutations--修改器，它只用于修改state中定义的状态变量
modules--模块，向store注入其它子模块，可以将其他模块以命名空间的方式引用。
strict--用于设置Vuex的运行模式，true为调试模式，false为生产模式
plugin--用于向Vuex加入运行期的插件。

由store的定义其实就可以看出一些结构上的端倪，store可以通过modules的注册形成树状的实例结构。


##data的替代者--state和Getter
Mutation是为力改变state内部的状态而存在的，为了不引起理解上的混淆，在此暂时先将其放下，后面再对他进行详细的讲解

复制是程序员的大忌，好代码绝对不能出现任何的复制！凡是可以被复制的代码就说明其可以被封装且有重用的需要，因此我们可以采用另一个方法从state中获取这些变量，这就是Vuex中的读取器Getter。

将从状态值直接读取数据转换成从读取器获取数据看起来似乎没有很大的区别，但是只要你仔细想一下Vue实例中data与computed两者之间的关系，你就能理解了--state相当于store实例的data，而getters就相当于store实例的computed

mapGetters本质上就是动态方法生成器，作用就是生成上面那些将store.getter方法映射为Vue实例的computed。

如果你的Getter带有复杂计算，那么测试它们是值得的。Getter本质上只是一个普通的JS函数，并不需要做什么特殊的配置，就当作普通的单元测试来写就可以了。
Action---操作的执行者
此时你可能会产生这样的疑惑，那应该在哪里使用vue-resource从服务器读取数据并分别写到state的各种属性中呢？首先继续强调的一点，一旦引入Vuex后，我们的Vue实例不能直接修改$store.state内的任意内容，要修改状态就要通过Mutation来修改。

Action是不能直接修改state中的状态的，每个action定义的第一个参数必然是一个与当前store实例结构相同的context对象，这个对象具有以下属性：
state--等同于store.state，若在模块中则为局部状态
rootState--等同于store.state，只存在于模块中
commit--等同于store.commit,用于提交一个mutation。
dispatch--等同于store.dispatch,用于调用其它action
dispatch--等同于store.dispatch，用于调用其它action
getters--等同于store.getters,获取store中的getters

##只用Mutation修改状态
当我们从远程数据库读取完数据后就要通知store调用一个Mutation来修改状，在Action中的写法有点像Vue实例内调用$emit触发事件。确实从理解上来说，Mutation就像是store内专属事件，它只能由store本身进行回调，当然也可以通过store.commit方法直接触发一个Mutation

Action也是不能直接调用的，它只能通过Vuex的dispatch方法向Vuex发出调用通知，由Vuex来找到这个指定的Action并执行

Vue2中的属性绑定都是单向的，也就是说，绑定到组件属性上的变量必须是只读的，不可改变的（Inmutatable），只有这样的变量才没有副作用。

## 用服务分离外部操作
当我们开始使用Vuex分离原有大量被掺合在组件中的各种状态管理之后，会慢慢地觉得Vuex并不是那么那以理解，也会体验到它确实让Vue回归了本原：一个制作界面的框架。在进行Vuex编程的过程中，不知道你是否回发现Actions内有大量相同或者相似的Vue.http的远程方式调用。它们显得如此类似，不雅，甚至让人感到臃肿

在实际的Vue项目开发过程中，RESTFul API调用可以说是无处不在，在Vue的生态圈内除了前文中推荐使用的vue-resource,还有其它一些功能类似的AJAX包，