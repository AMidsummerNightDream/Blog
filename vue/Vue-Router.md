## 路由的模式
传统意义上路由是由多个URL或者URL规则组成的，对服务端而言，网页的访问是无状态的，称之为服务端路由。而浏览器的History API则给予了一种实现可状态话页面的可能，因为页面的跳转（URL的改写）并不会出现页面的刷新，这样依赖状态就被维护在浏览器的History的内部状态存储之中
mode:history参数，这个值的意思是使用history模式，这种模式充分利用了history.pushState API来完成URL跳转而无须重新加载页面
 
无论我们是做服务端开发还是前端开发，路由的使用都有一个明确的原则：不直接引用路由定义

当显示引用路由定义的URL一旦产生变更，所有引用的地方都需要改，当程序开始规模化时路由变得越来越多的时候，这种变更所带来的工作量可想而知。所以我们应该在一开始就注意到这一点，vue-router提供了一种隐式的路由引用方式，vue-router将之称为“命名”路由，简单点说就是通过路由的名称引用取代URL的直接引用。

虽然命名路由的方式会比直接引用path多写一些代码，但这是值得的，因为一旦遇到路径的修改只需要在main.js的全局路由设置中进行修改而不用在每个用到的地方都改一次。

将参数作路由的习惯性做法不是在路由后面“参数=值”的方式，因为这种方式已经非常过时与老旧，而且可读性极差。我们可以将参数融入到路由的路径定义之内成为路径的一部分，使之更具可读性，我们称这种参数为“动态路径参数”，具体的做法是在参数名之前加上“：”，然后将参数写在路由的path内。

如果要同时传递多个参数，只要按以上的命名方法来加入参数，传递时在params中对应地声明参数即可，Vue-router只要匹配到路由模式的定义就会自动对参数进行分解取值。

当使用路由参数时，例如从/books/1导航到/books/2，原来的组件实例会被复用。因为这两个路由都渲染同一个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用，也就是说created，mounted等钩子函数在页面第二次加载时将失效。那么，当复用组件时，想对路由参数的变化做出响应的话，就需要在watch对象内添加对$router对象变化的跟踪函数：

$router.params定义的参数必然是整个路由的其中一部分，vue-router还可以让我们使用“path？参数=值”的方式，也就是俗称的查询字符串（Query string）传递数据。如果要从$router中读取Query string的参数，可以使用$router.query参数名的方式读取。除了params和query，vue-router还提供了一种常量参数定义meta，我们可以在路由定义中先定义meta值，然后在路由实例中通过$router.meta参数获取具体常量值

嵌套式路由
当我们将前文中首页的设计图与图书详情的设计图放在一起就会发现一个问题，如果按照之前的做法，那么所有的页面内都应该具有与首页相同的底部导航条，

## History的控制
当我们在使用HTML5的History模式的时候，每次路由的改变都会被推（push）到导航历史中保留，在某些情况下我们并不需要浏览器这样做，而是希望它能将原有的记录进行替换，那么我们就需要了解router-link是如何通过编程方式控制路由进行导航的。首先Vue实例内有一个$router对象，这个对象会提供三个方法，
|router的方法|属性|说明
|push（）|--|默认调用此方法
|append（）|--append（）|将目标URL追加到当前URL下
replace（）|replace|以目标URL替换现有URL

设置replace属性的话，当点击时，会调用router.replace()而不是router.push(),于是导航后不会留下History记录
设置append属性后，则在当前（相对）路径前天际基路径。

## 关于Fallback
由于我们将路由配置成History模式，如果我们直接在浏览器输入http://localhost/home，你会惊奇地发现浏览器会出现404错误
这是由于直接在浏览器输入http://localhost/home，浏览器就会直接将这个地址请求发送至服务器，先由服务器处理路由，而客户端路由的启动条件是要访问/index.html，这样的话客户端路由就完全失效了

解决办法是将所有发到服务器端的请求利用服务端的URLRewrite模版重新转发给/index.html，启动VueRouter进行处理，而浏览器地址栏的URL保持不变。

这个问题在开发期是不会出现的，因为我们在开发环境中使用的是webpack的DevServer，DevServer是对这个问题进行了处理，，只要打开webpack.config.js，找到devServer配置属性就可以见到

而当我们部署到生产环境时，就需要在Web服务器上进行一些简单配置以支持Fallback了

Apache
如果使用Apache就要在它的配置文件内加入以下URLRewrite模块的配置


