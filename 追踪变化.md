Vue最显著的功能就是响应式系统，它是一个典型的MVVM框架， 模型（Model）只是普通的JavaScript对象，修改它的视图（View）会自动更新。这种设计让状态管理变得非常简单而直观。

Model就是data方法返回的数据，视图（View）是最终在浏览器中显示的DOM。模型通过Observer，Dep，Watcher，Directive等一系列对象的关联，最终和视图建立起关系。归纳起来，Vue在这里做了3件事
1.通过Observer对data做监听，并且提供了订阅莫哥数据项变化的能力。
2.把template编译成一段document fragment，然后解析其中的Directive，得到每一个Directive所依赖的数据项和update方法
3.通过Watcher把上述两部分结合起来，即把Directive中的数据依赖通过Watcher订阅在对应数据Observer的Dep上。当数据变化时，就会触发Observer的Dep上的notify方法通知对应的Watcher的update，进而触发Directive的udate方法来更新DOM视图，最后达到模型和视图关联起来

Vue如何给data对象添加Observer？
Vue实例创建的过程会有一个生命周期，其中又一个过程就是调用vm._initData方法处理data选项。_initData方法源码如下

在_initData中我们要特别注意_proxy方法，它的功能就是遍历data的key，把data上的属性代理到vm实例上， _proxy方法源码如下：

_proxy方法主要通过Object.defineProperty的getter和setter方法实现了代理。

在_initData方法的最后，调用observe(data, this)方法来对data做监听。

observe方法首先判断value是否已经添加了__ob__属性，它是一个Observer对象的实例。如果是则直接使用，否则在value满足一些条件（数组或对象，可扩展，非Vue组件等）的情况下创建一个Observer对象。

Observer类的构造函数主要做了这么几件事：首先创建了一个Dep对象实例：然后把自身this添加到value的__ob__属性上。最后对value的类型进行判断，如果是数组则观察数组，否则观察单个元素。其实observeArray方法就是对数组进行遍历，递归调用observe方法，最终都会调用walk方法观察单个元素

walk方法是对obj的key进行遍历，一次调用convert方法，对obj的每一个属性进行转换，让它们拥有getter，setter方法。只有当obj是一个对象时，这个方法才能被调用。

convert方法调用了defineReactive方法，这里this.value就是要观察的data对象，key是data对象的某个属性， val则是这个属性的值。defineReactive的功能是把要观察的data对象的每个属性都赋予getter和setter方法。这样一旦属性被访问或者更新，我们就可以追踪岛这些变化。

defineReactive方法最核心的部分就是通过调用Object.defineProperty给data的每个属性添加getter和setter方法。当data的某个属性被访问时，则会调用getter方法，判断当Dep.target不为空时调用dep.depend和childObj.dep.depend方法做依赖收集。如果访问的属性是一个数组，则会遍历这个数组收集数组元素的依赖。当改变data的属性时，则会调用setter方法，这是调用dep.notify方法进行统治。这里我们提到了dep，它是Dep对象的实例。

Dep类时一个简单的观察者模式的实现。它的构造函数非常简单，初始化了id和subs。其中subs用来存储所有订阅它的Watcher，Dep.target表示当前正在计算的Watcher，它是全局唯一的，因为在同一时间只能有一个Watcher被计算。

在getter和setter方法调用时回分别调用dep.depend方法和dep.notify方法

depend方法通过Dep.target.addDep(this)方法把当前Dep的实例添加到当前正在计算的Watcher的依赖中。

notify方法遍历了所有的订阅Watcher，调用它们的update方法


Vue如何进行指令解析

Vue实例创建生命周期，在给data添加Observer之后，又一个构成就是调用vm._compile方法对模版进行编译。

通过el=transclude(el,option) 方法把template编译成一段document fragment，拿到el对象。而指令解析部分就是通过compile(el, options)方法实现的。

compile方法主要通过compileNode(el, options)方法完成节点的解析。如果节点拥有子节点，则调用compileNodeList(el.childNodes, options)完成子节点的解析。compileNodeList方法其实就是遍历子节点，递归调用compileNode方法。因为DOM元素本身就是树结构，这种递归方法也就是常见的树的深度遍历方法，者样就可以完成整个DOM树节点的解析。

compileNode方法对节点的nodeType做判断，如果是一个非script普通的元素（div，p等）;则调用compileElement（node,options)方法解析；如果是一个非空的文本节点，则调用compileTextNode（node,options)方法解析。

Directive实例在初始化Watcher时，会传入指令的expression。Watcher构造函数会通过parseExpression(expOrFn, this.twoWay)方法对expression做进一步的解析。passExpression方法的功能是把expression转换成一个对象。

Watcher.prototype.beforeGet很简单，设置Dep.target为当前Watcher实例，为接下来的依赖收集做准备。回到get方法,接下来执行this.getter.call(scope, scope)方法，这里的scope是this.vm,也就是当前Vue实例。这个方法相当于获取vm.times，这样就触发了对象的getter。

在之前已经设置了Dep.target为当前Watcher实例，所以接下来就调用dep.depend()方法完成依赖收集。它实际上是执行了Dep.target.addDep(this)  ,相当于执行了Watcher实例的addDep方法，把Dep实例添加到Watcher实例的依赖中。

Watcher.prototype.addDep方法就是把dep添加到Watcher实例的依赖中，同时又通过dep.addSub(this)把Watcher实例添加到dep的订阅者中。


Watcher.prototype.update方法在满足某些条件下会直接调用this.run方法，在多数情况下回调用pushWatcher(this)方法把Watcher实例推入队列中，延迟this.run调用的时机。pushWatcher方法就是把Watcher推入队列中，通过nextTick方法在下一个事件循环周期处理Watcher队列，这是Vue性能优化的手段。因为如果同时观察的数据多次变化，比如同步执行3次vm.time++,同步调用watcher.run就会触发3次DOM操作。而推入队列等待下一个事件循环周期再操作队列里的Watcher，因为是同一个Watcher，它只会调用一次watcher.run，从而只触发一次DOM操作。

flushBatcherQueue方法通过调用runBatcherQueue来run Watcher。这里我们看到Watcher队列分为内部queue和userQueue，其中userQueue是通过$watch()方法注册的Watcher。我们优先run内部queue来保证指令和DOM节点优先更新，这样当用户自定义的Watcher的回调函数触发时DOM已更新完毕。

runBatcherQunued的功能就是遍历queue中的Watcher的run方法。
